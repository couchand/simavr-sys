/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const ____gwchar_t_defined: ::std::os::raw::c_uint = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRI_avr_cycle_count: &'static [u8; 3usize] = b"lu\x00";
pub const MAX_AVR_COMMANDS: ::std::os::raw::c_uint = 32;
pub const MAX_CYCLE_TIMERS: ::std::os::raw::c_uint = 64;
pub const OLD_PC_SIZE: ::std::os::raw::c_uint = 32;
pub const AVR_FUSE_LOW: ::std::os::raw::c_uint = 0;
pub const AVR_FUSE_HIGH: ::std::os::raw::c_uint = 1;
pub const AVR_FUSE_EXT: ::std::os::raw::c_uint = 2;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const AVR_IOMEM_IRQ_ALL: ::std::os::raw::c_uint = 8;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
/// Public IRQ structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_irq_t {
    pub pool: *mut avr_irq_pool_t,
    pub name: *const ::std::os::raw::c_char,
    /// !< any value the user needs
    pub irq: u32,
    /// !< current value
    pub value: u32,
    /// !< IRQ_* flags
    pub flags: u8,
    /// !< list of hooks to be notified
    pub hook: *mut avr_irq_hook_t,
}
#[test]
fn bindgen_test_layout_avr_irq_t() {
    assert_eq!(::std::mem::size_of::<avr_irq_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( avr_irq_t ) ));
    assert_eq! (::std::mem::align_of::<avr_irq_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avr_irq_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_t ) ) . pool as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_t ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_t ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_t ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_t ) ) . irq as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_t ) , "::" ,
                stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_t ) ) . value as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_t ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_t ) ) . flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_t ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_t ) ) . hook as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_t ) , "::" ,
                stringify ! ( hook ) ));
}
impl Clone for avr_irq_t {
    fn clone(&self) -> Self { *self }
}
pub type avr_irq_notify_t =
    ::std::option::Option<unsafe extern "C" fn(irq: *mut avr_irq_t,
                                               value: u32,
                                               param:
                                                   *mut ::std::os::raw::c_void)>;
pub const IRQ_FLAG_NOT: _bindgen_ty_1 = _bindgen_ty_1::IRQ_FLAG_NOT;
pub const IRQ_FLAG_FILTERED: _bindgen_ty_1 = _bindgen_ty_1::IRQ_FLAG_FILTERED;
pub const IRQ_FLAG_ALLOC: _bindgen_ty_1 = _bindgen_ty_1::IRQ_FLAG_ALLOC;
pub const IRQ_FLAG_INIT: _bindgen_ty_1 = _bindgen_ty_1::IRQ_FLAG_INIT;
pub const IRQ_FLAG_FLOATING: _bindgen_ty_1 = _bindgen_ty_1::IRQ_FLAG_FLOATING;
pub const IRQ_FLAG_USER: _bindgen_ty_1 = _bindgen_ty_1::IRQ_FLAG_USER;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    IRQ_FLAG_NOT = 1,
    IRQ_FLAG_FILTERED = 2,
    IRQ_FLAG_ALLOC = 4,
    IRQ_FLAG_INIT = 8,
    IRQ_FLAG_FLOATING = 16,
    IRQ_FLAG_USER = 32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_irq_pool_t {
    /// !< number of irqs living in the pool
    pub count: ::std::os::raw::c_int,
    /// !< irqs belonging in this pool
    pub irq: *mut *mut avr_irq_t,
}
#[test]
fn bindgen_test_layout_avr_irq_pool_t() {
    assert_eq!(::std::mem::size_of::<avr_irq_pool_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( avr_irq_pool_t ) ));
    assert_eq! (::std::mem::align_of::<avr_irq_pool_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avr_irq_pool_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_pool_t ) ) . count as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_pool_t ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_irq_pool_t ) ) . irq as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_irq_pool_t ) , "::"
                , stringify ! ( irq ) ));
}
impl Clone for avr_irq_pool_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// ! allocates 'count' IRQs, initializes their "irq" starting from 'base' and increment
    pub fn avr_alloc_irq(pool: *mut avr_irq_pool_t, base: u32, count: u32,
                         names: *mut *const ::std::os::raw::c_char)
     -> *mut avr_irq_t;
}
extern "C" {
    pub fn avr_free_irq(irq: *mut avr_irq_t, count: u32);
}
extern "C" {
    /// ! init 'count' IRQs, initializes their "irq" starting from 'base' and increment
    pub fn avr_init_irq(pool: *mut avr_irq_pool_t, irq: *mut avr_irq_t,
                        base: u32, count: u32,
                        names: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    /// ! Returns the current IRQ flags
    pub fn avr_irq_get_flags(irq: *mut avr_irq_t) -> u8;
}
extern "C" {
    /// ! Sets this irq's flags
    pub fn avr_irq_set_flags(irq: *mut avr_irq_t, flags: u8);
}
extern "C" {
    /// ! 'raise' an IRQ. Ie call their 'hooks', and raise any chained IRQs, and set the new 'value'
    pub fn avr_raise_irq(irq: *mut avr_irq_t, value: u32);
}
extern "C" {
    /// ! Same as avr_raise_irq(), but also allow setting the float status
    pub fn avr_raise_irq_float(irq: *mut avr_irq_t, value: u32,
                               floating: ::std::os::raw::c_int);
}
extern "C" {
    /// ! this connects a "source" IRQ to a "destination" IRQ
    pub fn avr_connect_irq(src: *mut avr_irq_t, dst: *mut avr_irq_t);
}
extern "C" {
    pub fn avr_unconnect_irq(src: *mut avr_irq_t, dst: *mut avr_irq_t);
}
extern "C" {
    /// ! register a notification 'hook' for 'irq' -- 'param' is anything that your want passed back as argument
    pub fn avr_irq_register_notify(irq: *mut avr_irq_t,
                                   notify: avr_irq_notify_t,
                                   param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_irq_unregister_notify(irq: *mut avr_irq_t,
                                     notify: avr_irq_notify_t,
                                     param: *mut ::std::os::raw::c_void);
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
pub type avr_cycle_count_t = u64;
pub type avr_io_addr_t = u16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_regbit_t {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_avr_regbit_t() {
    assert_eq!(::std::mem::size_of::<avr_regbit_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( avr_regbit_t ) ));
    assert_eq! (::std::mem::align_of::<avr_regbit_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( avr_regbit_t ) ));
}
impl Clone for avr_regbit_t {
    fn clone(&self) -> Self { *self }
}
impl avr_regbit_t {
    #[inline]
    pub fn reg(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 511u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reg(&mut self, val: u32) {
        let mask = 511u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bit(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3584u64 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bit(&mut self, val: u32) {
        let mask = 3584u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1044480u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u32) {
        let mask = 1044480u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(reg: u32, bit: u32, mask: u32) -> u32 {
        ({
             ({ ({ 0 } | ((reg as u32 as u32) << 0usize) & (511u64 as u32)) }
                  | ((bit as u32 as u32) << 9usize) & (3584u64 as u32))
         } | ((mask as u32 as u32) << 12usize) & (1044480u64 as u32))
    }
}
#[repr(C)]
pub struct avr_t {
    pub mmcu: *const ::std::os::raw::c_char,
    pub ramend: u16,
    pub flashend: u32,
    pub e2end: u32,
    pub vector_size: u8,
    pub signature: [u8; 3usize],
    pub fuse: [u8; 6usize],
    pub lockbits: u8,
    pub rampz: avr_io_addr_t,
    pub eind: avr_io_addr_t,
    pub address_size: u8,
    pub reset_flags: avr_t__bindgen_ty_1,
    pub codeend: u32,
    pub state: ::std::os::raw::c_int,
    pub frequency: u32,
    pub vcc: u32,
    pub avcc: u32,
    pub aref: u32,
    pub cycle: avr_cycle_count_t,
    pub run_cycle_count: avr_cycle_count_t,
    pub run_cycle_limit: avr_cycle_count_t,
    /// Sleep requests are accumulated in sleep_usec until the minimum sleep value
/// is reached, at which point sleep_usec is cleared and the sleep request
/// is passed on to the operating system.
    pub sleep_usec: u32,
    pub init: ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t)>,
    pub reset: ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t)>,
    pub custom: avr_t__bindgen_ty_2,
    /// Default AVR core run function.
/// Two modes are available, a "raw" run that goes as fast as
/// it can, and a "gdb" mode that also watchouts for gdb events
/// and is a little bit slower.
    pub run: avr_run_t,
    /// Sleep default behaviour.
/// In "raw" mode, it calls usleep, in gdb mode, it waits
/// for howLong for gdb command on it's sockets.
    pub sleep: ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                                          howLong:
                                                              avr_cycle_count_t)>,
    /// Every IRQs will be stored in this pool. It is not
/// mandatory (yet) but will allow listing IRQs and their connections
    pub irq_pool: avr_irq_pool_t,
    pub sreg: [u8; 8usize],
    pub interrupt_state: i8,
    pub pc: avr_flashaddr_t,
    pub reset_pc: avr_flashaddr_t,
    pub io: [avr_t__bindgen_ty_3; 280usize],
    pub io_shared_io_count: ::std::os::raw::c_int,
    pub io_shared_io: [avr_t__bindgen_ty_4; 4usize],
    pub flash: *mut u8,
    pub data: *mut u8,
    pub io_port: *mut avr_io_t,
    pub commands: avr_cmd_table_t,
    pub cycle_timers: avr_cycle_timer_pool_t,
    pub interrupts: avr_int_table_t,
    pub _bitfield_1: u8,
    pub trace_data: *mut avr_trace_data_t,
    pub vcd: *mut avr_vcd_t,
    pub gdb: *mut avr_gdb_t,
    pub gdb_port: ::std::os::raw::c_int,
    pub io_console_buffer: avr_t__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_1 {
    pub porf: avr_regbit_t,
    pub extrf: avr_regbit_t,
    pub borf: avr_regbit_t,
    pub wdrf: avr_regbit_t,
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( avr_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_1 ) ) . porf as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_1 ) ,
                "::" , stringify ! ( porf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_1 ) ) . extrf as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_1 ) ,
                "::" , stringify ! ( extrf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_1 ) ) . borf as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_1 ) ,
                "::" , stringify ! ( borf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_1 ) ) . wdrf as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_1 ) ,
                "::" , stringify ! ( wdrf ) ));
}
impl Clone for avr_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_2 {
    pub init: ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                                         data:
                                                             *mut ::std::os::raw::c_void)>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                                           data:
                                                               *mut ::std::os::raw::c_void)>,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_2>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( avr_t__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_t__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_2 ) ) . init as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_2 ) ,
                "::" , stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_2 ) ) . deinit as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_2 ) ,
                "::" , stringify ! ( deinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_2 ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_2 ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for avr_t__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_3 {
    pub irq: *mut avr_irq_t,
    pub r: avr_t__bindgen_ty_3__bindgen_ty_1,
    pub w: avr_t__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_3__bindgen_ty_1 {
    pub param: *mut ::std::os::raw::c_void,
    pub c: avr_io_read_t,
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_3__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( avr_t__bindgen_ty_3__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_3__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                avr_t__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3__bindgen_ty_1 ) ) .
                param as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_t__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! (
                param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3__bindgen_ty_1 ) ) . c
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_t__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! ( c )
                ));
}
impl Clone for avr_t__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_3__bindgen_ty_2 {
    pub param: *mut ::std::os::raw::c_void,
    pub c: avr_io_write_t,
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_3__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( avr_t__bindgen_ty_3__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_3__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                avr_t__bindgen_ty_3__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3__bindgen_ty_2 ) ) .
                param as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_t__bindgen_ty_3__bindgen_ty_2 ) , "::" , stringify ! (
                param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3__bindgen_ty_2 ) ) . c
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_t__bindgen_ty_3__bindgen_ty_2 ) , "::" , stringify ! ( c )
                ));
}
impl Clone for avr_t__bindgen_ty_3__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_3>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( avr_t__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_t__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3 ) ) . irq as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_3 ) ,
                "::" , stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3 ) ) . r as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_3 ) ,
                "::" , stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_3 ) ) . w as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_3 ) ,
                "::" , stringify ! ( w ) ));
}
impl Clone for avr_t__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_4 {
    pub used: ::std::os::raw::c_int,
    pub io: [avr_t__bindgen_ty_4__bindgen_ty_1; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_4__bindgen_ty_1 {
    pub param: *mut ::std::os::raw::c_void,
    pub c: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_4__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( avr_t__bindgen_ty_4__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_4__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                avr_t__bindgen_ty_4__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_4__bindgen_ty_1 ) ) .
                param as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_t__bindgen_ty_4__bindgen_ty_1 ) , "::" , stringify ! (
                param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_4__bindgen_ty_1 ) ) . c
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_t__bindgen_ty_4__bindgen_ty_1 ) , "::" , stringify ! ( c )
                ));
}
impl Clone for avr_t__bindgen_ty_4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_4>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( avr_t__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_t__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_4 ) ) . used as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_4 ) ,
                "::" , stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_4 ) ) . io as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_4 ) ,
                "::" , stringify ! ( io ) ));
}
impl Clone for avr_t__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_t__bindgen_ty_5 {
    pub buf: *mut ::std::os::raw::c_char,
    pub size: u32,
    pub len: u32,
}
#[test]
fn bindgen_test_layout_avr_t__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<avr_t__bindgen_ty_5>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( avr_t__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<avr_t__bindgen_ty_5>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_t__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_5 ) ) . buf as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_5 ) ,
                "::" , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_5 ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_5 ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t__bindgen_ty_5 ) ) . len as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t__bindgen_ty_5 ) ,
                "::" , stringify ! ( len ) ));
}
impl Clone for avr_t__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_avr_t() {
    assert_eq!(::std::mem::size_of::<avr_t>() , 16008usize , concat ! (
               "Size of: " , stringify ! ( avr_t ) ));
    assert_eq! (::std::mem::align_of::<avr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . mmcu as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( mmcu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . ramend as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( ramend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . flashend as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( flashend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . e2end as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( e2end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . vector_size as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( vector_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . signature as * const _ as
                usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . fuse as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( fuse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . lockbits as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( lockbits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . rampz as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( rampz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . eind as * const _ as usize }
                , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( eind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . address_size as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( address_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . reset_flags as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( reset_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . codeend as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( codeend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . state as * const _ as usize }
                , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . frequency as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( frequency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . vcc as * const _ as usize } ,
                68usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( vcc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . avcc as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( avcc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . aref as * const _ as usize }
                , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( aref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . cycle as * const _ as usize }
                , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( cycle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . run_cycle_count as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( run_cycle_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . run_cycle_limit as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( run_cycle_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . sleep_usec as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( sleep_usec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . init as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . reset as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . custom as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( custom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . run as * const _ as usize } ,
                152usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( run ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . sleep as * const _ as usize }
                , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( sleep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . irq_pool as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( irq_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . sreg as * const _ as usize }
                , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( sreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . interrupt_state as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( interrupt_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . pc as * const _ as usize } ,
                196usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . reset_pc as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( reset_pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . io as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . io_shared_io_count as * const
                _ as usize } , 11408usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( io_shared_io_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . io_shared_io as * const _ as
                usize } , 11416usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( io_shared_io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . flash as * const _ as usize }
                , 11704usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( flash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . data as * const _ as usize }
                , 11712usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . io_port as * const _ as usize
                } , 11720usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( io_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . commands as * const _ as
                usize } , 11728usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( commands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . cycle_timers as * const _ as
                usize } , 12248usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( cycle_timers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . interrupts as * const _ as
                usize } , 14312usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( interrupts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . trace_data as * const _ as
                usize } , 15960usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( trace_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . vcd as * const _ as usize } ,
                15968usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( vcd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . gdb as * const _ as usize } ,
                15976usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( gdb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . gdb_port as * const _ as
                usize } , 15984usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( gdb_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_t ) ) . io_console_buffer as * const
                _ as usize } , 15992usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_t ) , "::" ,
                stringify ! ( io_console_buffer ) ));
}
impl avr_t {
    #[inline]
    pub fn trace(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn log(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 30u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_log(&mut self, val: u8) {
        let mask = 30u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(trace: u8, log: u8) -> u8 {
        ({ ({ 0 } | ((trace as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((log as u8 as u8) << 1usize) & (30u64 as u8))
    }
}
pub const AVR_INT_IRQ_PENDING: _bindgen_ty_2 =
    _bindgen_ty_2::AVR_INT_IRQ_PENDING;
pub const AVR_INT_IRQ_RUNNING: _bindgen_ty_2 =
    _bindgen_ty_2::AVR_INT_IRQ_RUNNING;
pub const AVR_INT_IRQ_COUNT: _bindgen_ty_2 = _bindgen_ty_2::AVR_INT_IRQ_COUNT;
pub const AVR_INT_ANY: _bindgen_ty_2 = _bindgen_ty_2::AVR_INT_ANY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    AVR_INT_IRQ_PENDING = 0,
    AVR_INT_IRQ_RUNNING = 1,
    AVR_INT_IRQ_COUNT = 2,
    AVR_INT_ANY = 255,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_int_vector_t {
    pub vector: u8,
    pub enable: avr_regbit_t,
    pub raised: avr_regbit_t,
    pub irq: [avr_irq_t; 2usize],
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_avr_int_vector_t() {
    assert_eq!(::std::mem::size_of::<avr_int_vector_t>() , 104usize , concat !
               ( "Size of: " , stringify ! ( avr_int_vector_t ) ));
    assert_eq! (::std::mem::align_of::<avr_int_vector_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( avr_int_vector_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_vector_t ) ) . vector as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_vector_t ) ,
                "::" , stringify ! ( vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_vector_t ) ) . enable as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_vector_t ) ,
                "::" , stringify ! ( enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_vector_t ) ) . raised as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_vector_t ) ,
                "::" , stringify ! ( raised ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_vector_t ) ) . irq as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_vector_t ) ,
                "::" , stringify ! ( irq ) ));
}
impl Clone for avr_int_vector_t {
    fn clone(&self) -> Self { *self }
}
impl avr_int_vector_t {
    #[inline]
    pub fn pending(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_pending(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn trace(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn raise_sticky(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_raise_sticky(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pending: u8, trace: u8, raise_sticky: u8) -> u8 {
        ({
             ({ ({ 0 } | ((pending as u8 as u8) << 0usize) & (1u64 as u8)) } |
                  ((trace as u8 as u8) << 1usize) & (2u64 as u8))
         } | ((raise_sticky as u8 as u8) << 2usize) & (4u64 as u8))
    }
}
pub type avr_int_vector_p = *mut avr_int_vector_t;
pub const avr_int_pending_overflow_f: _bindgen_ty_3 =
    _bindgen_ty_3::avr_int_pending_overflow_f;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 { avr_int_pending_overflow_f = 1, }
pub const avr_int_pending_fifo_size: _bindgen_ty_4 =
    _bindgen_ty_4::avr_int_pending_fifo_size;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { avr_int_pending_fifo_size = 64, }
#[repr(C)]
pub struct avr_int_pending_t {
    pub buffer: [avr_int_vector_p; 64usize],
    pub read: u16,
    pub write: u16,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_avr_int_pending_t() {
    assert_eq!(::std::mem::size_of::<avr_int_pending_t>() , 520usize , concat
               ! ( "Size of: " , stringify ! ( avr_int_pending_t ) ));
    assert_eq! (::std::mem::align_of::<avr_int_pending_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( avr_int_pending_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_pending_t ) ) . buffer as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_pending_t ) ,
                "::" , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_pending_t ) ) . read as * const _
                as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_pending_t ) ,
                "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_pending_t ) ) . write as * const
                _ as usize } , 514usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_pending_t ) ,
                "::" , stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_pending_t ) ) . flags as * const
                _ as usize } , 516usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_pending_t ) ,
                "::" , stringify ! ( flags ) ));
}
#[repr(C)]
pub struct avr_int_table_t {
    pub vector: [*mut avr_int_vector_t; 64usize],
    pub vector_count: u8,
    pub pending: avr_int_pending_t,
    pub running_ptr: u8,
    pub running: [*mut avr_int_vector_t; 64usize],
    pub irq: [avr_irq_t; 2usize],
}
#[test]
fn bindgen_test_layout_avr_int_table_t() {
    assert_eq!(::std::mem::size_of::<avr_int_table_t>() , 1640usize , concat !
               ( "Size of: " , stringify ! ( avr_int_table_t ) ));
    assert_eq! (::std::mem::align_of::<avr_int_table_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( avr_int_table_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_table_t ) ) . vector as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_table_t ) ,
                "::" , stringify ! ( vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_table_t ) ) . vector_count as *
                const _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_table_t ) ,
                "::" , stringify ! ( vector_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_table_t ) ) . pending as * const
                _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_table_t ) ,
                "::" , stringify ! ( pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_table_t ) ) . running_ptr as *
                const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_table_t ) ,
                "::" , stringify ! ( running_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_table_t ) ) . running as * const
                _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_table_t ) ,
                "::" , stringify ! ( running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_int_table_t ) ) . irq as * const _ as
                usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_int_table_t ) ,
                "::" , stringify ! ( irq ) ));
}
pub type avr_int_table_p = *mut avr_int_table_t;
extern "C" {
    pub fn avr_register_vector(avr: *mut avr_t,
                               vector: *mut avr_int_vector_t);
}
extern "C" {
    pub fn avr_raise_interrupt(avr: *mut avr_t, vector: *mut avr_int_vector_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_has_pending_interrupts(avr: *mut avr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_is_interrupt_pending(avr: *mut avr_t,
                                    vector: *mut avr_int_vector_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_clear_interrupt(avr: *mut avr_t,
                               vector: *mut avr_int_vector_t);
}
extern "C" {
    pub fn avr_service_interrupts(avr: *mut avr_t);
}
extern "C" {
    pub fn avr_interrupt_reti(avr: *mut avr_t);
}
extern "C" {
    pub fn avr_clear_interrupt_if(avr: *mut avr_t,
                                  vector: *mut avr_int_vector_t, old: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_get_interrupt_irq(avr: *mut avr_t, v: u8) -> *mut avr_irq_t;
}
extern "C" {
    pub fn avr_interrupt_init(avr: *mut avr_t);
}
extern "C" {
    pub fn avr_interrupt_reset(avr: *mut avr_t);
}
pub type avr_cmd_handler_t =
    ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t, v: u8,
                                               param:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_cmd_t {
    pub handler: avr_cmd_handler_t,
    pub param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_avr_cmd_t() {
    assert_eq!(::std::mem::size_of::<avr_cmd_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( avr_cmd_t ) ));
    assert_eq! (::std::mem::align_of::<avr_cmd_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avr_cmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cmd_t ) ) . handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cmd_t ) , "::" ,
                stringify ! ( handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cmd_t ) ) . param as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cmd_t ) , "::" ,
                stringify ! ( param ) ));
}
impl Clone for avr_cmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_cmd_table_t {
    pub table: [avr_cmd_t; 32usize],
    pub pending: *mut avr_cmd_t,
}
#[test]
fn bindgen_test_layout_avr_cmd_table_t() {
    assert_eq!(::std::mem::size_of::<avr_cmd_table_t>() , 520usize , concat !
               ( "Size of: " , stringify ! ( avr_cmd_table_t ) ));
    assert_eq! (::std::mem::align_of::<avr_cmd_table_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( avr_cmd_table_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cmd_table_t ) ) . table as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cmd_table_t ) ,
                "::" , stringify ! ( table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cmd_table_t ) ) . pending as * const
                _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cmd_table_t ) ,
                "::" , stringify ! ( pending ) ));
}
impl Clone for avr_cmd_table_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn avr_cmd_set_register(avr: *mut avr_t, addr: avr_io_addr_t);
}
extern "C" {
    pub fn avr_cmd_register(avr: *mut avr_t, code: u8,
                            handler: avr_cmd_handler_t,
                            param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_cmd_unregister(avr: *mut avr_t, code: u8);
}
extern "C" {
    pub fn avr_cmd_init(avr: *mut avr_t);
}
pub type avr_cycle_timer_t =
    ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                               when: avr_cycle_count_t,
                                               param:
                                                   *mut ::std::os::raw::c_void)
                              -> avr_cycle_count_t>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_cycle_timer_slot_t {
    pub next: *mut avr_cycle_timer_slot_t,
    pub when: avr_cycle_count_t,
    pub timer: avr_cycle_timer_t,
    pub param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_avr_cycle_timer_slot_t() {
    assert_eq!(::std::mem::size_of::<avr_cycle_timer_slot_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( avr_cycle_timer_slot_t )
               ));
    assert_eq! (::std::mem::align_of::<avr_cycle_timer_slot_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_cycle_timer_slot_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_slot_t ) ) . next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_slot_t
                ) , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_slot_t ) ) . when as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_slot_t
                ) , "::" , stringify ! ( when ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_slot_t ) ) . timer as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_slot_t
                ) , "::" , stringify ! ( timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_slot_t ) ) . param as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_slot_t
                ) , "::" , stringify ! ( param ) ));
}
impl Clone for avr_cycle_timer_slot_t {
    fn clone(&self) -> Self { *self }
}
pub type avr_cycle_timer_slot_p = *mut avr_cycle_timer_slot_t;
#[repr(C)]
pub struct avr_cycle_timer_pool_t {
    pub timer_slots: [avr_cycle_timer_slot_t; 64usize],
    pub timer_free: avr_cycle_timer_slot_p,
    pub timer: avr_cycle_timer_slot_p,
}
#[test]
fn bindgen_test_layout_avr_cycle_timer_pool_t() {
    assert_eq!(::std::mem::size_of::<avr_cycle_timer_pool_t>() , 2064usize ,
               concat ! ( "Size of: " , stringify ! ( avr_cycle_timer_pool_t )
               ));
    assert_eq! (::std::mem::align_of::<avr_cycle_timer_pool_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( avr_cycle_timer_pool_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_pool_t ) ) . timer_slots
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_pool_t
                ) , "::" , stringify ! ( timer_slots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_pool_t ) ) . timer_free
                as * const _ as usize } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_pool_t
                ) , "::" , stringify ! ( timer_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_cycle_timer_pool_t ) ) . timer as *
                const _ as usize } , 2056usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_cycle_timer_pool_t
                ) , "::" , stringify ! ( timer ) ));
}
pub type avr_cycle_timer_pool_p = *mut avr_cycle_timer_pool_t;
extern "C" {
    pub fn avr_cycle_timer_register(avr: *mut avr_t, when: avr_cycle_count_t,
                                    timer: avr_cycle_timer_t,
                                    param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_cycle_timer_register_usec(avr: *mut avr_t, when: u32,
                                         timer: avr_cycle_timer_t,
                                         param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_cycle_timer_cancel(avr: *mut avr_t, timer: avr_cycle_timer_t,
                                  param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_cycle_timer_status(avr: *mut avr_t, timer: avr_cycle_timer_t,
                                  param: *mut ::std::os::raw::c_void)
     -> avr_cycle_count_t;
}
extern "C" {
    pub fn avr_cycle_timer_process(avr: *mut avr_t) -> avr_cycle_count_t;
}
extern "C" {
    pub fn avr_cycle_timer_reset(avr: *mut avr_t);
}
pub type avr_flashaddr_t = u32;
pub type avr_io_read_t =
    ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                               addr: avr_io_addr_t,
                                               param:
                                                   *mut ::std::os::raw::c_void)
                              -> u8>;
pub type avr_io_write_t =
    ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                               addr: avr_io_addr_t, v: u8,
                                               param:
                                                   *mut ::std::os::raw::c_void)>;
pub const S_C: _bindgen_ty_5 = _bindgen_ty_5::S_C;
pub const S_Z: _bindgen_ty_5 = _bindgen_ty_5::S_Z;
pub const S_N: _bindgen_ty_5 = _bindgen_ty_5::S_N;
pub const S_V: _bindgen_ty_5 = _bindgen_ty_5::S_V;
pub const S_S: _bindgen_ty_5 = _bindgen_ty_5::S_S;
pub const S_H: _bindgen_ty_5 = _bindgen_ty_5::S_H;
pub const S_T: _bindgen_ty_5 = _bindgen_ty_5::S_T;
pub const S_I: _bindgen_ty_5 = _bindgen_ty_5::S_I;
pub const R_XL: _bindgen_ty_5 = _bindgen_ty_5::R_XL;
pub const R_XH: _bindgen_ty_5 = _bindgen_ty_5::R_XH;
pub const R_YL: _bindgen_ty_5 = _bindgen_ty_5::R_YL;
pub const R_YH: _bindgen_ty_5 = _bindgen_ty_5::R_YH;
pub const R_ZL: _bindgen_ty_5 = _bindgen_ty_5::R_ZL;
pub const R_ZH: _bindgen_ty_5 = _bindgen_ty_5::R_ZH;
pub const R_SPL: _bindgen_ty_5 = _bindgen_ty_5::R_SPL;
pub const R_SPH: _bindgen_ty_5 = _bindgen_ty_5::R_SPH;
pub const R_SREG: _bindgen_ty_5 = _bindgen_ty_5::R_SREG;
pub const MAX_IOs: _bindgen_ty_5 = _bindgen_ty_5::MAX_IOs;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    S_C = 0,
    S_Z = 1,
    S_N = 2,
    S_V = 3,
    S_S = 4,
    S_H = 5,
    S_T = 6,
    S_I = 7,
    R_XL = 26,
    R_XH = 27,
    R_YL = 28,
    R_YH = 29,
    R_ZL = 30,
    R_ZH = 31,
    R_SPL = 93,
    R_SPH = 94,
    R_SREG = 95,
    MAX_IOs = 280,
}
pub const LOG_NONE: _bindgen_ty_6 = _bindgen_ty_6::LOG_NONE;
pub const LOG_OUTPUT: _bindgen_ty_6 = _bindgen_ty_6::LOG_OUTPUT;
pub const LOG_ERROR: _bindgen_ty_6 = _bindgen_ty_6::LOG_ERROR;
pub const LOG_WARNING: _bindgen_ty_6 = _bindgen_ty_6::LOG_WARNING;
pub const LOG_TRACE: _bindgen_ty_6 = _bindgen_ty_6::LOG_TRACE;
pub const LOG_DEBUG: _bindgen_ty_6 = _bindgen_ty_6::LOG_DEBUG;
#[repr(u32)]
/// Logging macros and associated log levels.
/// The current log level is kept in avr->log.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    LOG_NONE = 0,
    LOG_OUTPUT = 1,
    LOG_ERROR = 2,
    LOG_WARNING = 3,
    LOG_TRACE = 4,
    LOG_DEBUG = 5,
}
pub const cpu_Limbo: _bindgen_ty_7 = _bindgen_ty_7::cpu_Limbo;
pub const cpu_Stopped: _bindgen_ty_7 = _bindgen_ty_7::cpu_Stopped;
pub const cpu_Running: _bindgen_ty_7 = _bindgen_ty_7::cpu_Running;
pub const cpu_Sleeping: _bindgen_ty_7 = _bindgen_ty_7::cpu_Sleeping;
pub const cpu_Step: _bindgen_ty_7 = _bindgen_ty_7::cpu_Step;
pub const cpu_StepDone: _bindgen_ty_7 = _bindgen_ty_7::cpu_StepDone;
pub const cpu_Done: _bindgen_ty_7 = _bindgen_ty_7::cpu_Done;
pub const cpu_Crashed: _bindgen_ty_7 = _bindgen_ty_7::cpu_Crashed;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    cpu_Limbo = 0,
    cpu_Stopped = 1,
    cpu_Running = 2,
    cpu_Sleeping = 3,
    cpu_Step = 4,
    cpu_StepDone = 5,
    cpu_Done = 6,
    cpu_Crashed = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_trace_data_t {
    pub codeline: *mut *mut avr_symbol_t,
    pub old: [avr_trace_data_t__bindgen_ty_1; 32usize],
    pub old_pci: ::std::os::raw::c_int,
    pub touched: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_trace_data_t__bindgen_ty_1 {
    pub pc: u32,
    pub sp: u16,
}
#[test]
fn bindgen_test_layout_avr_trace_data_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<avr_trace_data_t__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( avr_trace_data_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<avr_trace_data_t__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( avr_trace_data_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_trace_data_t__bindgen_ty_1 ) ) . pc
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_trace_data_t__bindgen_ty_1 ) , "::" , stringify ! ( pc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_trace_data_t__bindgen_ty_1 ) ) . sp
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                avr_trace_data_t__bindgen_ty_1 ) , "::" , stringify ! ( sp )
                ));
}
impl Clone for avr_trace_data_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_avr_trace_data_t() {
    assert_eq!(::std::mem::size_of::<avr_trace_data_t>() , 304usize , concat !
               ( "Size of: " , stringify ! ( avr_trace_data_t ) ));
    assert_eq! (::std::mem::align_of::<avr_trace_data_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( avr_trace_data_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_trace_data_t ) ) . codeline as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_trace_data_t ) ,
                "::" , stringify ! ( codeline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_trace_data_t ) ) . old as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_trace_data_t ) ,
                "::" , stringify ! ( old ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_trace_data_t ) ) . old_pci as * const
                _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_trace_data_t ) ,
                "::" , stringify ! ( old_pci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_trace_data_t ) ) . touched as * const
                _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_trace_data_t ) ,
                "::" , stringify ! ( touched ) ));
}
impl Clone for avr_trace_data_t {
    fn clone(&self) -> Self { *self }
}
pub type avr_run_t =
    ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_kind_t {
    pub names: [*const ::std::os::raw::c_char; 4usize],
    pub make: ::std::option::Option<unsafe extern "C" fn() -> *mut avr_t>,
}
#[test]
fn bindgen_test_layout_avr_kind_t() {
    assert_eq!(::std::mem::size_of::<avr_kind_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( avr_kind_t ) ));
    assert_eq! (::std::mem::align_of::<avr_kind_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avr_kind_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_kind_t ) ) . names as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_kind_t ) , "::" ,
                stringify ! ( names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_kind_t ) ) . make as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_kind_t ) , "::" ,
                stringify ! ( make ) ));
}
impl Clone for avr_kind_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_symbol_t {
    pub addr: u32,
    pub symbol: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_avr_symbol_t() {
    assert_eq!(::std::mem::size_of::<avr_symbol_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( avr_symbol_t ) ));
    assert_eq! (::std::mem::align_of::<avr_symbol_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( avr_symbol_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_symbol_t ) ) . addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_symbol_t ) , "::" ,
                stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_symbol_t ) ) . symbol as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_symbol_t ) , "::" ,
                stringify ! ( symbol ) ));
}
impl Clone for avr_symbol_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn avr_make_mcu_by_name(name: *const ::std::os::raw::c_char)
     -> *mut avr_t;
}
extern "C" {
    pub fn avr_init(avr: *mut avr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_core_allocate(core: *const avr_t, coreLen: u32) -> *mut avr_t;
}
extern "C" {
    pub fn avr_reset(avr: *mut avr_t);
}
extern "C" {
    pub fn avr_run(avr: *mut avr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_terminate(avr: *mut avr_t);
}
extern "C" {
    pub fn avr_set_command_register(avr: *mut avr_t, addr: avr_io_addr_t);
}
extern "C" {
    pub fn avr_set_console_register(avr: *mut avr_t, addr: avr_io_addr_t);
}
extern "C" {
    pub fn avr_loadcode(avr: *mut avr_t, code: *mut u8, size: u32,
                        address: avr_flashaddr_t);
}
extern "C" {
    pub fn avr_core_watch_write(avr: *mut avr_t, addr: u16, v: u8);
}
extern "C" {
    pub fn avr_core_watch_read(avr: *mut avr_t, addr: u16) -> u8;
}
extern "C" {
    pub fn avr_sadly_crashed(avr: *mut avr_t, signal: u8);
}
extern "C" {
    pub fn avr_global_logger(avr: *mut avr_t, level: ::std::os::raw::c_int,
                             format: *const ::std::os::raw::c_char, ...);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type avr_logger_p =
    ::std::option::Option<unsafe extern "C" fn(avr: *mut avr_t,
                                               level: ::std::os::raw::c_int,
                                               format:
                                                   *const ::std::os::raw::c_char,
                                               ap: *mut __va_list_tag)>;
extern "C" {
    pub fn avr_global_logger_set(logger: avr_logger_p);
}
extern "C" {
    pub fn avr_global_logger_get() -> avr_logger_p;
}
extern "C" {
    pub fn avr_callback_sleep_gdb(avr: *mut avr_t,
                                  howLong: avr_cycle_count_t);
}
extern "C" {
    pub fn avr_callback_run_gdb(avr: *mut avr_t);
}
extern "C" {
    pub fn avr_callback_sleep_raw(avr: *mut avr_t,
                                  howLong: avr_cycle_count_t);
}
extern "C" {
    pub fn avr_callback_run_raw(avr: *mut avr_t);
}
extern "C" {
    /// Accumulates sleep requests (and returns a sleep time of 0) until
/// a minimum count of requested sleep microseconds are reached
/// (low amounts cannot be handled accurately).
/// This function is an utility function for the sleep callbacks
    pub fn avr_pending_sleep_usec(avr: *mut avr_t, howLong: avr_cycle_count_t)
     -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_io_t {
    pub next: *mut avr_io_t,
    pub avr: *mut avr_t,
    pub kind: *const ::std::os::raw::c_char,
    pub irq_names: *mut *const ::std::os::raw::c_char,
    pub irq_ioctl_get: u32,
    pub irq_count: ::std::os::raw::c_int,
    pub irq: *mut avr_irq_t,
    pub reset: ::std::option::Option<unsafe extern "C" fn(io: *mut avr_io_t)>,
    pub ioctl: ::std::option::Option<unsafe extern "C" fn(io: *mut avr_io_t,
                                                          ctl: u32,
                                                          io_param:
                                                              *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int>,
    pub dealloc: ::std::option::Option<unsafe extern "C" fn(io:
                                                                *mut avr_io_t)>,
}
#[test]
fn bindgen_test_layout_avr_io_t() {
    assert_eq!(::std::mem::size_of::<avr_io_t>() , 72usize , concat ! (
               "Size of: " , stringify ! ( avr_io_t ) ));
    assert_eq! (::std::mem::align_of::<avr_io_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avr_io_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . next as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . avr as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( avr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . kind as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . irq_names as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( irq_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . irq_ioctl_get as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( irq_ioctl_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . irq_count as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( irq_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . irq as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . reset as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . ioctl as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( ioctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avr_io_t ) ) . dealloc as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( avr_io_t ) , "::" ,
                stringify ! ( dealloc ) ));
}
impl Clone for avr_io_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn avr_register_io(avr: *mut avr_t, io: *mut avr_io_t);
}
extern "C" {
    pub fn avr_io_setirqs(io: *mut avr_io_t, ctl: u32,
                          count: ::std::os::raw::c_int, irqs: *mut avr_irq_t)
     -> *mut avr_irq_t;
}
extern "C" {
    pub fn avr_register_io_read(avr: *mut avr_t, addr: avr_io_addr_t,
                                read: avr_io_read_t,
                                param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_register_io_write(avr: *mut avr_t, addr: avr_io_addr_t,
                                 write: avr_io_write_t,
                                 param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn avr_ioctl(avr: *mut avr_t, ctl: u32,
                     io_param: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avr_io_getirq(avr: *mut avr_t, ctl: u32,
                         index: ::std::os::raw::c_int) -> *mut avr_irq_t;
}
extern "C" {
    pub fn avr_iomem_getirq(avr: *mut avr_t, addr: avr_io_addr_t,
                            name: *const ::std::os::raw::c_char,
                            index: ::std::os::raw::c_int) -> *mut avr_irq_t;
}
extern "C" {
    pub fn avr_deallocate_ios(avr: *mut avr_t);
}
/// !< list of hooks to be notified
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_irq_hook_t {
    pub _address: u8,
}
impl Clone for avr_irq_hook_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_vcd_t {
    pub _address: u8,
}
impl Clone for avr_vcd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avr_gdb_t {
    pub _address: u8,
}
impl Clone for avr_gdb_t {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
